{"/home/travis/build/npmtest/node-npmtest-spotify-web/test.js":"/* istanbul instrument in package npmtest_spotify_web */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-spotify-web/lib.npmtest_spotify_web.js":"/* istanbul instrument in package npmtest_spotify_web */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_spotify_web = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_spotify_web = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-spotify-web/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-spotify-web && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_spotify_web */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_spotify_web\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_spotify_web.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_spotify_web.rollup.js'] =\n            local.assetsDict['/assets.npmtest_spotify_web.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_spotify_web.__dirname + '/lib.npmtest_spotify_web.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-spotify-web/node_modules/spotify-web/index.js":"module.exports = require('./lib/spotify');\n","/home/travis/build/npmtest/node-npmtest-spotify-web/node_modules/spotify-web/lib/spotify.js":"/**\n * Module dependencies.\n */\n\nvar vm = require('vm');\nvar util = require('./util');\nvar http = require('http');\nvar WebSocket = require('ws');\nvar cheerio = require('cheerio');\nvar schemas = require('./schemas');\nvar superagent = require('superagent');\nvar inherits = require('util').inherits;\nvar SpotifyError = require('./error');\nvar EventEmitter = require('events').EventEmitter;\nvar debug = require('debug')('spotify-web');\nvar pkg = require('../package.json');\n\n/**\n * Module exports.\n */\n\nmodule.exports = Spotify;\n\n/**\n * Protocol Buffer types.\n */\n\nvar MercuryMultiGetRequest = schemas.build('mercury','MercuryMultiGetRequest');\nvar MercuryMultiGetReply = schemas.build('mercury','MercuryMultiGetReply');\nvar MercuryRequest = schemas.build('mercury','MercuryRequest');\n\nvar Artist = require('./artist');\nvar Album = require('./album');\nvar Track = require('./track');\nvar Image = require('./image');\nrequire('./restriction');\n\nvar SelectedListContent = schemas.build('playlist4','SelectedListContent');\n\nvar StoryRequest = schemas.build('bartender','StoryRequest');\nvar StoryList = schemas.build('bartender','StoryList');\n\n/**\n * Re-export all the `util` functions.\n */\n\nObject.keys(util).forEach(function (key) {\n  Spotify[key] = util[key];\n});\n\n/**\n * Create instance and login convenience function.\n *\n * @param {String} un username\n * @param {String} pw password\n * @param {Function} fn callback function\n * @api public\n */\n\nSpotify.login = function (un, pw, fn) {\n  if (!fn) fn = function () {};\n  var spotify = new Spotify();\n  spotify.login(un, pw, function (err) {\n    if (err) return fn(err);\n    fn.call(spotify, null, spotify);\n  });\n  return spotify;\n};\n\n/**\n * Spotify Web base class.\n *\n * @api public\n */\n\nfunction Spotify () {\n  if (!(this instanceof Spotify)) return new Spotify();\n  EventEmitter.call(this);\n\n  this.seq = 0;\n  this.heartbeatInterval = 18E4; // 180s, from \"spotify.web.client.js\"\n  this.agent = superagent.agent();\n  this.connected = false; // true after the WebSocket \"connect\" message is sent\n  this._callbacks = Object.create(null);\n\n  this.authServer = 'play.spotify.com';\n  this.authUrl = '/xhr/json/auth.php';\n  this.landingUrl = '/';\n  this.userAgent = 'Mozilla/5.0 (Chrome/13.37 compatible-ish) spotify-web/' + pkg.version;\n\n  // base URLs for Image files like album artwork, artist prfiles, etc.\n  // these values taken from \"spotify.web.client.js\"\n  this.sourceUrl = 'https://d3rt1990lpmkn.cloudfront.net';\n  this.sourceUrls = {\n    tiny:   this.sourceUrl + '/60/',\n    small:  this.sourceUrl + '/120/',\n    normal: this.sourceUrl + '/300/',\n    large:  this.sourceUrl + '/640/',\n    avatar: this.sourceUrl + '/artist_image/'\n  };\n\n  // mappings for the protobuf `enum Size`\n  this.sourceUrls.DEFAULT = this.sourceUrls.normal;\n  this.sourceUrls.SMALL = this.sourceUrls.tiny;\n  this.sourceUrls.LARGE = this.sourceUrls.large;\n  this.sourceUrls.XLARGE = this.sourceUrls.avatar;\n\n  // WebSocket callbacks\n  this._onopen = this._onopen.bind(this);\n  this._onclose = this._onclose.bind(this);\n  this._onmessage = this._onmessage.bind(this);\n\n  // start the \"heartbeat\" once the WebSocket connection is established\n  this.once('connect', this._startHeartbeat);\n\n  // handle \"message\" commands...\n  this.on('message', this._onmessagecommand);\n\n  // needs to emulate Spotify's \"CodeValidator\" object\n  this._context = vm.createContext();\n  this._context.reply = this._reply.bind(this);\n\n  // binded callback for when user doesn't pass a callback function\n  this._defaultCallback = this._defaultCallback.bind(this);\n}\ninherits(Spotify, EventEmitter);\n\n/**\n * Creates the connection to the Spotify Web websocket server and logs in using\n * the given Spotify `username` and `password` credentials.\n *\n * @param {String} un username\n * @param {String} pw password\n * @param {Function} fn callback function\n * @api public\n */\n\nSpotify.prototype.login = function (un, pw, fn) {\n  debug('Spotify#login(%j, %j)', un, pw.replace(/./g, '*'));\n\n  // save credentials for later...\n  this.creds = { username: un, password: pw, type: 'sp' };\n\n  this._setLoginCallbacks(fn);\n  this._makeLandingPageRequest();\n};\n\n/**\n * Creates the connection to the Spotify Web websocket server and logs in using\n * an anonymous identity.\n *\n * @param {Function} fn callback function\n * @api public\n */\n\nSpotify.prototype.anonymousLogin = function (fn) {\n  debug('Spotify#anonymousLogin()');\n\n  // save credentials for later...\n  this.creds = { type: 'anonymous' };\n\n  this._setLoginCallbacks(fn);\n  this._makeLandingPageRequest();\n};\n\n/**\n * Creates the connection to the Spotify Web websocket server and logs in using\n * the given Facebook App OAuth token and corresponding user ID.\n *\n * @param {String} fbuid facebook user Id\n * @param {String} token oauth token\n * @param {Function} fn callback function\n * @api public\n */\n\nSpotify.prototype.facebookLogin = function (fbuid, token, fn) {\n  debug('Spotify#facebookLogin(%j, %j)', fbuid, token);\n\n  // save credentials for later...\n  this.creds = { fbuid: fbuid, token: token, type: 'fb' };\n\n  this._setLoginCallbacks(fn);\n  this._makeLandingPageRequest();\n};\n\n/**\n * Sets the login and error callbacks to invoke the specified callback function\n *\n * @param {Function} fn callback function\n * @api private\n */\n\nSpotify.prototype._setLoginCallbacks = function(fn) {\n  var self = this;\n  function onLogin () {\n    cleanup();\n    fn();\n  }\n  function onError (err) {\n    cleanup();\n    fn(err);\n  }\n  function cleanup () {\n    self.removeListener('login', onLogin);\n    self.removeListener('error', onError);\n  }\n  if ('function' == typeof fn) {\n    this.on('login', onLogin);\n    this.on('error', onError);\n  }\n};\n\n/**\n * Makes a request for the landing page to get the CSRF token.\n *\n * @api private\n */\n\nSpotify.prototype._makeLandingPageRequest = function() {\n  var url = 'https://' + this.authServer + this.landingUrl;\n  debug('GET %j', url);\n  this.agent.get(url)\n    .set({ 'User-Agent': this.userAgent })\n    .end(this._onsecret.bind(this));\n};\n\n/**\n * Called when the Facebook redirect URL GET (and any necessary redirects) has\n * responded.\n *\n * @api private\n */\n\nSpotify.prototype._onsecret = function (err, res) {\n  if (err) return this.emit('error', err);\n\n  debug('landing page: %d status code, %j content-type', res.statusCode, res.headers['content-type']);\n  var $ = cheerio.load(res.text);\n\n  // need to grab the CSRF token and trackingId from the page.\n  // currently, it's inside an Object that gets passed to a\n  // `new Spotify.Web.Login()` call as the second parameter.\n  var args;\n  var scripts = $('script');\n  function login (doc, data) {\n    debug('Spotify.Web.Login()');\n    args = data;\n    return { init: function () { /* noop */ } };\n  }\n  for (var i = 0; i < scripts.length; i++) {\n    var code = scripts.eq(i).text();\n    if (~code.indexOf('Spotify.Web.Login')) {\n      vm.runInNewContext(code, { document: null, Spotify: { Web: { Login: login, App: { initialize: function() { } } } } });\n    }\n  }\n  debug('login CSRF token: %j, tracking ID: %j', args.csrftoken, args.trackingId);\n\n  // construct credentials object to send from stored credentials\n  var creds = this.creds;\n  delete this.creds;\n  creds.secret = args.csrftoken;\n  creds.trackingId = args.trackingId;\n  creds.landingURL = args.landingURL;\n  creds.referrer = args.referrer;\n  creds.cf = null;\n\n  // now we have to \"auth\" in order to get Spotify Web \"credentials\"\n  var url = 'https://' + this.authServer + this.authUrl;\n  debug('POST %j', url);\n  this.agent.post(url)\n    .set({ 'User-Agent': this.userAgent })\n    .type('form')\n    .send(creds)\n    .end(this._onauth.bind(this));\n};\n\n/**\n * Called upon the \"auth\" endpoint's HTTP response.\n *\n * @api private\n */\n\nSpotify.prototype._onauth = function (err, res) {\n  if (err) return this.emit('error', err);\n\n  debug('auth %d status code, %j content-type', res.statusCode, res.headers['content-type']);\n  if ('ERROR' == res.body.status) {\n    // got an error...\n    var msg = res.body.error;\n    if (res.body.message) msg += ': ' + res.body.message;\n    this.emit('error', new Error(msg));\n  } else {\n    this.settings = res.body.config;\n    this._resolveAP();\n  }\n};\n\n/**\n * Resolves the WebSocket AP to connect to\n * Should be called after the _onauth() function\n *\n * @api private\n */\n\nSpotify.prototype._resolveAP = function () {\n  var query = { client: '24:0:0:' + this.settings.version };\n  var resolver = this.settings.aps.resolver;\n  debug('ap resolver %j', resolver);\n  if (resolver.site) query.site = resolver.site;\n\n  // connect to the AP resolver endpoint in order to determine\n  // the WebSocket server URL to connect to next\n  var url = 'http://' + resolver.hostname;\n  debug('GET %j', url);\n  this.agent.get(url)\n    .set({ 'User-Agent': this.userAgent })\n    .query(query)\n    .end(this._openWebsocket.bind(this));\n};\n\n/**\n * Opens the WebSocket connection to the Spotify Web server.\n * Should be called upon AP resolver's response.\n *\n * @api private.\n */\n\nSpotify.prototype._openWebsocket = function (err, res) {\n  if (err) return this.emit('error', err);\n\n  debug('ap resolver %d status code, %j content-type', res.statusCode, res.headers['content-type']);\n  var ap_list = res.body.ap_list;\n  var url = 'wss://' + ap_list[0] + '/';\n\n  debug('WS %j', url);\n  this.ws = new WebSocket(url, null, {\"origin\": \"https://play.spotify.com\", \"headers\":{\"User-Agent\": this.userAgent}});\n  this.ws.on('open', this._onopen);\n  this.ws.on('close', this._onclose);\n  this.ws.on('message', this._onmessage);\n};\n\n/**\n * WebSocket \"open\" event.\n *\n * @api private\n */\n\nSpotify.prototype._onopen = function () {\n  debug('WebSocket \"open\" event');\n  this.emit('open');\n  if (!this.connected) {\n    // need to send \"connect\" message\n    this.connect();\n  }\n};\n\n/**\n * WebSocket \"close\" event.\n *\n * @api private\n */\n\nSpotify.prototype._onclose = function () {\n  debug('WebSocket \"close\" event');\n  this.emit('close');\n  if (this.connected) {\n    this.disconnect();\n  }\n};\n\n/**\n * WebSocket \"message\" event.\n *\n * @param {String}\n * @api private\n */\n\nSpotify.prototype._onmessage = function (data) {\n  debug('WebSocket \"message\" event: %s', data);\n  var msg;\n  try {\n    msg = JSON.parse(data);\n  } catch (e) {\n    return this.emit('error', e);\n  }\n\n  var self = this;\n  var id = msg.id;\n  var callbacks = this._callbacks;\n\n  function fn (err, res) {\n    var cb = callbacks[id];\n    if (cb) {\n      // got a callback function!\n      delete callbacks[id];\n      cb.call(self, err, res, msg);\n    }\n  }\n\n  if ('error' in msg) {\n    var err = new SpotifyError(msg.error);\n    if (null == id) {\n      this.emit('error', err);\n    } else {\n      fn(err);\n    }\n  } else if ('message' in msg) {\n    var command = msg.message[0];\n    var args = msg.message.slice(1);\n    this.emit('message', command, args);\n  } else if ('id' in msg) {\n    fn(null, msg);\n  } else {\n    // unhandled command\n    console.error(msg);\n    throw new Error('TODO: implement!');\n  }\n};\n\n/**\n * Handles a \"message\" command. Specifically, handles the \"do_work\" command and\n * executes the specified JavaScript in the VM.\n *\n * @api private\n */\n\nSpotify.prototype._onmessagecommand = function (command, args) {\n  if ('do_work' == command) {\n    var js = args[0];\n    debug('got \"do_work\" payload: %j', js);\n    try {\n      vm.runInContext(js, this._context);\n    } catch (e) {\n      this.emit('error', e);\n    }\n  } else if ('ping_flash2' == command) {\n    this.sendPong(args[0]);\n  } else if ('login_complete' == command) {\n    this.sendCommand('sp/log', [41, 1, 0, 0, 0, 0]); // Spotify.Logging.Logger#logWindowSize\n    this.sendCommand('sp/user_info', this._onuserinfo.bind(this));\n  } else {\n    // unhandled message\n    console.error(command, args);\n    throw new Error('TODO: implement!');\n  }\n};\n\n/**\n * Called when the \"sp/work_done\" command is completed.\n *\n * @api private\n */\n\nSpotify.prototype._onworkdone = function (err, res) {\n  if (err) return this.emit('error', err);\n  debug('\"sp/work_done\" ACK');\n};\n\n/**\n * Responds to a `sp/ping_flash2` request.\n *\n * This request is usually handled by Flash, and in a perfect world we would\n * execute the \"original\" Flash code directly with Shumway or equivalent.\n * Unfortunately the player.swf file is compiled with C code via Adobe Alchemy,\n * and therefore doesn't work with Shumway at this time.\n * See: http://git.io/qCWplA\n *\n * Instead, this function calls out to a web service that is running the\n * `player.swf` file in a web browser, and proxies the ping request to the\n * web browser and sends us back the response. Not ideal, but it works…\n * See: http://git.io/WyCx0Q\n *\n * @param {String} ping the argument sent from the request\n */\n\nSpotify.prototype.sendPong = function(ping) {\n  this.agent\n  .get('http://ping-pong.spotify.nodestuff.net/' + ping.split(\" \").join(\"-\"))\n  .set({ 'User-Agent': this.userAgent })\n  .type(\"json\")\n  .end(function (err, res) {\n    if (err) return this.emit('error', err);\n\n    if (res.body.status == 100) {\n      pong = res.body.pong.split(\"-\").join(\" \");\n      this.sendCommand('sp/pong_flash2', [ pong ]);\n    }\n  }.bind(this));\n};\n\n/**\n * Sends a \"message\" across the WebSocket connection with the given \"name\" and\n * optional Array of arguments.\n *\n * @param {String} name command name\n * @param {Array} args optional Array or arguments to send\n * @param {Function} fn callback function\n * @api public\n */\n\nSpotify.prototype.sendCommand = function (name, args, fn) {\n  if ('function' == typeof args) {\n    fn = args;\n    args = [];\n  }\n  debug('sendCommand(%j, %j)', name, args);\n  var msg = {\n    name: name,\n    id: String(this.seq++),\n    args: args || []\n  };\n  if ('function' == typeof fn) {\n    // store callback function for later\n    debug('storing callback function for message id %s', msg.id);\n    this._callbacks[msg.id] = fn;\n  }\n  var data = JSON.stringify(msg);\n  debug('sending command: %s', data);\n  try {\n    this.ws.send(data);\n  } catch (e) {\n    this.emit('error', e);\n  }\n};\n\n/**\n * Makes a Protobuf request over the WebSocket connection.\n * Also known as a MercuryRequest or Hermes Call.\n *\n * @param {Object} req protobuf request object\n * @param {Function} fn (optional) callback function\n * @api public\n */\n\nSpotify.prototype.sendProtobufRequest = function(req, fn) {\n  debug('sendProtobufRequest(%j)', req);\n\n  // extract request object\n  var isMultiGet = req.isMultiGet || false;\n  var payload = req.payload || [];\n  var header = {\n      uri: '',\n      method: '',\n      source: '',\n      contentType: isMultiGet ? 'vnd.spotify/mercury-mget-request' : ''\n  };\n  if (req.header) {\n    header.uri = req.header.uri || '';\n    header.method = req.header.method || '';\n    header.source = req.header.source || '';\n  }\n\n  // load payload and response schemas\n  var loadSchema = function(schema, dontRecurse) {\n    if ('string' === typeof schema) {\n      var schemaName = schema.split(\"#\");\n      schema = schemas.build(schemaName[0], schemaName[1]);\n      if (!schema)\n        throw new Error('Could not load schema: ' + schemaName.join('#'));\n    } else if (schema && !dontRecurse && (!schema.hasOwnProperty('parse') && !schema.hasOwnProperty('serialize'))) {\n      var keys = Object.keys(schema);\n      keys.forEach(function(key) {\n        schema[key] = loadSchema(schema[key], true);\n      });\n    }\n    return schema;\n  };\n\n  var payloadSchema = isMultiGet ? MercuryMultiGetRequest : loadSchema(req.payloadSchema);\n  var responseSchema = loadSchema(req.responseSchema);\n  var isMultiResponseSchema = (!responseSchema.hasOwnProperty('parse'));\n\n  var parseData = function(type, data, dontRecurse) {\n    var parser = responseSchema;\n    var ret;\n    if (!dontRecurse && 'vnd.spotify/mercury-mget-reply' == type) {\n      ret = [];\n      var response = self._parse(MercuryMultiGetReply, data);\n      response.reply.forEach(function(reply) {\n        var data = parseData(reply.contentType, new Buffer(reply.body, 'base64'), true);\n        ret.push(data);\n      });\n      debug('parsed multi-get response - %d items', ret.length);\n    } else {\n      if (isMultiResponseSchema) {\n        if (responseSchema.hasOwnProperty(type)) {\n          parser = responseSchema[type];\n        } else {\n          throw new Error('Unrecognised metadata type: ' + type);\n        }\n      }\n      ret = self._parse(parser, data);\n      debug('parsed response: [ %j ] %j', type, ret);\n    }\n    return ret;\n  };\n\n  function getNumber (method) {\n    switch(method) {\n    case \"SUB\":\n      return 1;\n    case \"UNSUB\":\n      return 2;\n    default:\n      return 0;\n    }\n  }\n\n  // construct request\n  var args = [ getNumber(header.method) ];\n  var data = MercuryRequest.serialize(header).toString('base64');\n  args.push(data);\n\n  if (isMultiGet) {\n    if (Array.isArray(req.payload)) {\n      req.payload = {request: req.payload};\n    } else if (!req.payload.request) {\n      throw new Error('Invalid payload for Multi-Get Request.');\n    }\n  }\n\n  if (payload && payloadSchema) {\n    data = payloadSchema.serialize(req.payload).toString('base64');\n    args.push(data);\n  }\n\n  // send request and parse response, pass data back to callback\n  var self = this;\n  this.sendCommand('sp/hm_b64', args, function (err, res) {\n    if ('function' !== typeof fn) return; // give up if no callback\n    if (err) return fn(err);\n\n    var header = self._parse(MercuryRequest, new Buffer(res.result[0], 'base64'));\n    debug('response header: %j', header);\n\n    // TODO: proper error handling, handle 300 errors\n\n    var message;\n    if (header.statusCode >= 400 && header.statusCode < 500) {\n      message = header.statusMessage || http.STATUS_CODES[header.statusCode] || 'Unknown Error';\n      return fn(new Error('Client Error: ' + message + ' (' + header.statusCode + ')'));\n    }\n\n    if (header.statusCode >= 500 && header.statusCode < 600) {\n      message = header.statusMessage || http.STATUS_CODES[header.statusCode] || 'Unknown Error';\n      return fn(new Error('Server Error: ' + message + ' (' + header.statusCode + ')'));\n    }\n\n    if (isMultiGet && 'vnd.spotify/mercury-mget-reply' !== header.contentType)\n      return fn(new Error('Server Error: Server didn\\'t send a multi-GET reply for a multi-GET request!'));\n\n    var data = parseData(header.contentType, new Buffer(res.result[1], 'base64'));\n    fn(null, data);\n  });\n};\n\n/**\n * Sends the \"connect\" command. Should be called once the WebSocket connection is\n * established.\n *\n * @param {Function} fn callback function\n * @api public\n */\n\nSpotify.prototype.connect = function (fn) {\n  debug('connect()');\n  var creds = this.settings.credentials[0].split(':');\n  var args = [ creds[0], creds[1], creds.slice(2).join(':') ];\n  this.sendCommand('connect', args, this._onconnect.bind(this));\n};\n\n/**\n * Closes the WebSocket connection of present. This effectively ends your Spotify\n * Web \"session\" (and derefs from the event-loop, so your program can exit).\n *\n * @api public\n */\n\nSpotify.prototype.disconnect = function () {\n  debug('disconnect()');\n  this.connected = false;\n  clearInterval(this._heartbeatId);\n  this._heartbeatId = null;\n  if (this.ws) {\n    this.ws.close();\n    this.ws = null;\n  }\n};\n\n/**\n * Gets the \"metadata\" object for one or more URIs.\n *\n * @param {Array|String} uris A single URI, or an Array of URIs to get \"metadata\" for\n * @param {Function} fn callback function\n * @api public\n */\n\nSpotify.prototype.get =\nSpotify.prototype.metadata = function (uris, fn) {\n  debug('metadata(%j)', uris);\n  if (!Array.isArray(uris)) {\n    uris = [ uris ];\n  }\n  // array of \"request\" Objects that will be protobuf'd\n  var requests = [];\n  var mtype = '';\n  uris.forEach(function (uri) {\n    var type = util.uriType(uri);\n    if ('local' == type) {\n      debug('ignoring \"local\" track URI: %j', uri);\n      return;\n    }\n    var id = util.uri2id(uri);\n    mtype = type;\n    requests.push({\n      method: 'GET',\n      uri: 'hm://metadata/' + type + '/' + id\n    });\n  });\n\n\n  var header = {\n    method: 'GET',\n    uri: 'hm://metadata/' + mtype + 's'\n  };\n  var multiGet = true;\n  if (requests.length == 1) {\n    header = requests[0];\n    requests = null;\n    multiGet = false;\n  }\n\n  this.sendProtobufRequest({\n    header: header,\n    payload: requests,\n    isMultiGet: multiGet,\n    responseSchema: {\n      'vnd.spotify/metadata-artist': Artist,\n      'vnd.spotify/metadata-album': Album,\n      'vnd.spotify/metadata-track': Track\n    }\n  }, function(err, item) {\n    if (err) return fn(err);\n    item._loaded = true;\n    fn(null, item);\n  });\n};\n\n/**\n * Gets the metadata from a Spotify \"playlist\" URI.\n *\n * @param {String} uri playlist uri\n * @param {Number} from (optional) the start index. defaults to 0.\n * @param {Number} length (optional) number of tracks to get. defaults to 100.\n * @param {Function} fn callback function\n * @api public\n */\n\nSpotify.prototype.playlist = function (uri, from, length, fn) {\n  // argument surgery\n  if ('function' == typeof from) {\n    fn = from;\n    from = length = null;\n  } else if ('function' == typeof length) {\n    fn = length;\n    length = null;\n  }\n  if (null == from) from = 0;\n  if (null == length) length = 100;\n\n  debug('playlist(%j, %j, %j)', uri, from, length);\n  var self = this;\n  var parts = uri.split(':');\n  var user = parts[2];\n  var id = parts[4];\n  var hm = 'hm://playlist/user/' + user + '/playlist/' + id +\n    '?from=' + from + '&length=' + length;\n\n  this.sendProtobufRequest({\n    header: {\n      method: 'GET',\n      uri: hm\n    },\n    responseSchema: SelectedListContent\n  }, fn);\n};\n\n/**\n * Gets a user's starred playlist\n *\n * @param {Number} from (optional) the start index. defaults to 0.\n * @param {Number} length (optional) number of tracks to get. defaults to 100.\n * @param {Function} fn callback function\n * @api public\n */\n\nSpotify.prototype.starred = function (user, from, length, fn) {\n  // argument surgery\n  if ('function' == typeof from) {\n    fn = from;\n    from = length = null;\n  } else if ('function' == typeof length) {\n    fn = length;\n    length = null;\n  }\n  if (null == from) from = 0;\n  if (null == length) length = 100;\n\n  debug('starred(%j, %j, %j)', user, from, length);\n\n  var self = this;\n  var hm = 'hm://playlist/user/' + user + '/starred?from=' + from + '&length=' + length;\n\n  this.sendProtobufRequest({\n    header: {\n      method: 'GET',\n      uri: hm\n    },\n    responseSchema: SelectedListContent\n  }, fn);\n};\n\n/**\n * Gets the user's stored playlists\n *\n * @param {String} user (optional) the username for the rootlist you want to retrieve. defaults to current user.\n * @param {Number} from (optional) the start index. defaults to 0.\n * @param {Number} length (optional) number of tracks to get. defaults to 100.\n * @param {Function} fn callback function\n * @api public\n */\n\nSpotify.prototype.rootlist = function (user, from, length, fn) {\n  // argument surgery\n  if ('function' == typeof user) {\n    fn = user;\n    from = length = user = null;\n  } else if ('function' == typeof from) {\n    fn = from;\n    from = length = null;\n  } else if ('function' == typeof length) {\n    fn = length;\n    length = null;\n  }\n  if (null == user) user = this.username;\n  if (null == from) from = 0;\n  if (null == length) length = 100;\n\n  debug('rootlist(%j, %j, %j)', user, from, length);\n\n  var self = this;\n  var hm = 'hm://playlist/user/' + user + '/publishedrootlist?from=' + from + '&length=' + length;\n\n  this.sendProtobufRequest({\n    header: {\n      method: 'GET',\n      uri: hm\n    },\n    responseSchema: SelectedListContent\n  }, fn);\n};\n\n/**\n * Retrieve suggested similar tracks to the given track URI\n *\n * @param {String} uri track uri\n * @param {Function} fn callback function\n * @api public\n */\n\nSpotify.prototype.similar = function(uri, fn) {\n  debug('similar(%j)', uri);\n\n  var parts = uri.split(':');\n  var type = parts[1];\n  var id = parts[2];\n\n  if (!type || !id || 'track' != type)\n    throw new Error('uri must be a track uri');\n\n  this.sendProtobufRequest({\n    header: {\n      method: 'GET',\n      uri: 'hm://similarity/suggest/' + id\n    },\n    payload: {\n      country: this.country || 'US',\n      language: this.settings.locale.current || 'en',\n      device: 'web'\n    },\n    payloadSchema: StoryRequest,\n    responseSchema: StoryList\n  }, fn);\n};\n\n/**\n * Gets the MP3 160k audio URL for the given \"track\" metadata object.\n *\n * @param {Object} track Track \"metadata\" instance\n * @param {Function} fn callback function\n * @api public\n */\n\nSpotify.prototype.trackUri = function (track, fn) {\n  debug('trackUri()');\n  // TODO: make \"format\" configurable here\n  this.recurseAlternatives(track, this.country, function (err, track) {\n    if (err) return fn(err);\n    var args = [ 'mp3160', util.gid2id(track.gid) ];\n    debug('sp/track_uri args: %j', args);\n    this.sendCommand('sp/track_uri', args, function (err, res) {\n      if (err) return fn(err);\n      fn(null, res.result);\n    });\n  }.bind(this));\n};\n\n/**\n * Checks if the given track \"metadata\" object is \"available\" for playback, taking\n * account for the allowed/forbidden countries, the user's current country, the\n * user's account type (free/paid), etc.\n *\n * @param {Object} track Track \"metadata\" instance\n * @param {String} country 2 letter country code to check if the track is playable for\n * @return {Boolean} true if track is playable, false otherwise\n * @api public\n */\n\nSpotify.prototype.isTrackAvailable = function (track, country) {\n  if (!country) country = this.country;\n  debug('isTrackAvailable()');\n\n  var allowed = [];\n  var forbidden = [];\n  var available = false;\n  var restriction;\n\n  if (Array.isArray(track.restriction)) {\n    for (var i = 0; i < track.restriction.length; i++) {\n      restriction = track.restriction[i];\n      allowed.push.apply(allowed, restriction.allowed);\n      forbidden.push.apply(forbidden, restriction.forbidden);\n\n      var isAllowed = !restriction.hasOwnProperty('countriesAllowed') || has(allowed, country);\n      var isForbidden = has(forbidden, country) && forbidden.length > 0;\n\n      // guessing at names here, corrections welcome...\n      var accountTypeMap = {\n        premium: 'SUBSCRIPTION',\n        unlimited: 'SUBSCRIPTION',\n        free: 'AD'\n      };\n\n      if (has(allowed, country) && has(forbidden, country)) {\n        isAllowed = true;\n        isForbidden = false;\n      }\n\n      var type = accountTypeMap[this.accountType] || 'AD';\n      var applicable = has(restriction.catalogue, type);\n\n      available = isAllowed && !isForbidden && applicable;\n\n      //debug('restriction: %j', restriction);\n      debug('type: %j', type);\n      debug('allowed: %j', allowed);\n      debug('forbidden: %j', forbidden);\n      debug('isAllowed: %j', isAllowed);\n      debug('isForbidden: %j', isForbidden);\n      debug('applicable: %j', applicable);\n      debug('available: %j', available);\n\n      if (available) break;\n    }\n  }\n  return available;\n};\n\n/**\n * Checks if the given \"track\" is \"available\". If yes, returns the \"track\"\n * untouched. If no, then the \"alternative\" tracks array on the \"track\" instance\n * is searched until one of them is \"available\", and then returns that \"track\".\n * If none of the alternative tracks are \"available\", returns `null`.\n *\n * @param {Object} track Track \"metadata\" instance\n * @param {String} country 2 letter country code to attempt to find a playable \"track\" for\n * @param {Function} fn callback function\n * @api public\n */\n\nSpotify.prototype.recurseAlternatives = function (track, country, fn) {\n  debug('recurseAlternatives()');\n  function done () {\n    process.nextTick(function () {\n      fn(null, track);\n    });\n  }\n  if (this.isTrackAvailable(track, country)) {\n    return done();\n  } else if (Array.isArray(track.alternative)) {\n    var tracks = track.alternative;\n    for (var i = 0; i < tracks.length; i++) {\n      debug('checking alternative track %j', track.uri);\n      track = tracks[i];\n      if (this.isTrackAvailable(track, country)) {\n        return done();\n      }\n    }\n  }\n  // not playable\n  process.nextTick(function () {\n    fn(new Error('Track is not playable in country \"' + country + '\"'));\n  });\n};\n\n/**\n * Executes a \"search\" against the Spotify music library. Note that the response\n * is an XML data String, so you must parse it yourself.\n *\n * @param {String|Object} opts string search term, or options object with search\n * @param {Function} fn callback function\n * @api public\n */\n\nSpotify.prototype.search = function (opts, fn) {\n  if ('string' == typeof opts) {\n    opts = { query: opts };\n  }\n  if (null == opts.maxResults || opts.maxResults > 50) {\n    opts.maxResults = 50;\n  }\n  if (null == opts.type) {\n    opts.type = 'all';\n  }\n  if (null == opts.offset) {\n    opts.offset = 0;\n  }\n  if (null == opts.query) {\n    throw new Error('must pass a \"query\" option!');\n  }\n\n  var types = {\n    tracks: 1,\n    albums: 2,\n    artists: 4,\n    playlists: 8\n  };\n  var type;\n  if ('all' == opts.type) {\n    type = types.tracks | types.albums | types.artists | types.playlists;\n  } else if (Array.isArray(opts.type)) {\n    type = 0;\n    opts.type.forEach(function (t) {\n      if (!types.hasOwnProperty(t)) {\n        throw new Error('unknown search \"type\": ' + opts.type);\n      }\n      type |= types[t];\n    });\n  } else if (opts.type in types) {\n    type = types[opts.type];\n  } else {\n    throw new Error('unknown search \"type\": ' + opts.type);\n  }\n\n  var args = [ opts.query, type, opts.maxResults, opts.offset ];\n  this.sendCommand('sp/search', args, function (err, res) {\n    if (err) return fn(err);\n    // XML-parsing is left up to the user, since they may want to use libxmljs,\n    // or node-sax, or node-xml2js, or whatever. So leave it up to them...\n    fn(null, res.result);\n  });\n};\n\n/**\n * Sends the \"sp/track_end\" event. This is required after each track is played,\n * otherwise Spotify limits you to 3 track URL fetches per session.\n *\n * @param {String} lid the track \"lid\"\n * @param {String} uri track spotify uri (not playback uri)\n * @param {Number} ms number of milliseconds played\n * @param {Function} fn callback function\n * @api public\n */\n\nSpotify.prototype.sendTrackEnd = function (lid, uri, ms, fn) {\n  debug('sendTrackEnd(%j, %j, %j)', lid, uri, ms);\n  if (!fn) fn = this._defaultCallback;\n\n  var ms_played = Number(ms);\n  var ms_played_union = ms_played;\n  var n_seeks_forward = 0;\n  var n_seeks_backward = 0;\n  var ms_seeks_forward = 0;\n  var ms_seeks_backward = 0;\n  var ms_latency = 100;\n  var display_track = null;\n  var play_context = 'unknown';\n  var source_start = 'unknown';\n  var source_end = 'unknown';\n  var reason_start = 'unknown';\n  var reason_end = 'unknown';\n  var referrer = 'unknown';\n  var referrer_version = '0.1.0';\n  var referrer_vendor = 'com.spotify';\n  var max_continuous = ms_played;\n  var args = [\n    lid,\n    ms_played,\n    ms_played_union,\n    n_seeks_forward,\n    n_seeks_backward,\n    ms_seeks_forward,\n    ms_seeks_backward,\n    ms_latency,\n    display_track,\n    play_context,\n    source_start,\n    source_end,\n    reason_start,\n    reason_end,\n    referrer,\n    referrer_version,\n    referrer_vendor,\n    max_continuous\n  ];\n  this.sendCommand('sp/track_end', args, function (err, res) {\n    if (err) return fn(err);\n    if (null == res.result) {\n      // apparently no result means \"ok\"\n      fn();\n    } else {\n      // TODO: handle error case\n    }\n  });\n};\n\n/**\n * Sends the \"sp/track_event\" event. These are pause and play events (possibly\n * others).\n *\n * @param {String} lid the track \"lid\"\n * @param {String} event\n * @param {Number} ms number of milliseconds played so far\n * @param {Function} fn callback function\n * @api public\n */\n\nSpotify.prototype.sendTrackEvent = function (lid, event, ms, fn) {\n  debug('sendTrackEvent(%j, %j, %j)', lid, event, ms);\n  var num = event;\n  var args = [ lid, num, ms ];\n  this.sendCommand('sp/track_event', args, function (err, res) {\n    if (err) return fn(err);\n    console.log(res);\n  });\n};\n\n/**\n * Sends the \"sp/track_progress\" event. Should be called periodically while\n * playing a Track.\n *\n * @param {String} lid the track \"lid\"\n * @param {Number} ms number of milliseconds played so far\n * @param {Function} fn callback function\n * @api public\n */\n\nSpotify.prototype.sendTrackProgress = function (lid, ms, fn) {\n  debug('sendTrackProgress(%j, %j)', lid, ms);\n  var ms_played = Number(ms);\n  var source_start = 'unknown';\n  var reason_start = 'unknown';\n  var ms_latency = 100;\n  var play_context = 'unknown';\n  var display_track = '';\n  var referrer = 'unknown';\n  var referrer_version = '0.1.0';\n  var referrer_vendor = 'com.spotify';\n  var args = [\n    lid,\n    source_start,\n    reason_start,\n    ms_played,\n    ms_latency,\n    play_context,\n    display_track,\n    referrer,\n    referrer_version,\n    referrer_vendor\n  ];\n  this.sendCommand('sp/track_progress', args, function (err, res) {\n    if (err) return fn(err);\n    console.log(res);\n  });\n};\n\n/**\n * \"connect\" command callback function. If the result was \"ok\", then get the\n * logged in user's info.\n *\n * @param {Object} res response Object\n * @api private\n */\n\nSpotify.prototype._onconnect = function (err, res) {\n  if (err) return this.emit('error', err);\n  if ('ok' == res.result) {\n    this.connected = true;\n    this.emit('connect');\n  } else {\n    // TODO: handle possible error case\n  }\n};\n\n/**\n * \"sp/user_info\" command callback function. Once this is complete, the \"login\"\n * event is emitted and control is passed back to the user for the first time.\n *\n * @param {Object} res response Object\n * @api private\n */\n\nSpotify.prototype._onuserinfo = function (err, res) {\n  if (err) return this.emit('error', err);\n  this.username = res.result.user;\n  this.country = res.result.country;\n  this.accountType = res.result.catalogue;\n  this.emit('login');\n};\n\n/**\n * Starts the interval that sends and \"sp/echo\" command to the Spotify server\n * every 18 seconds.\n *\n * @api private\n */\n\nSpotify.prototype._startHeartbeat = function () {\n  debug('starting heartbeat every %s seconds', this.heartbeatInterval / 1000);\n  var fn = this._onheartbeat.bind(this);\n  this._heartbeatId = setInterval(fn, this.heartbeatInterval);\n};\n\n/**\n * Sends an \"sp/echo\" command.\n *\n * @api private\n */\n\nSpotify.prototype._onheartbeat = function () {\n  this.sendCommand('sp/echo', 'h');\n};\n\n/**\n * Called when `this.reply()` is called in the \"do_work\" payload.\n *\n * @api private\n */\n\nSpotify.prototype._reply = function () {\n  var args = Array.prototype.slice.call(arguments);\n  debug('reply(%j)', args);\n  this.sendCommand('sp/work_done', args, this._onworkdone);\n};\n\n/**\n * Default callback function for when the user does not pass a\n * callback function of their own.\n *\n * @param {Error} err\n * @api private\n */\n\nSpotify.prototype._defaultCallback = function (err) {\n  if (err) this.emit('error', err);\n};\n\n/**\n * Wrapper around the Protobuf Schema's `parse()` function that also attaches this\n * Spotify instance as `_spotify` to each entry in the parsed object. This is\n * necessary so that instance methods (like `Track#play()`) have access to the\n * Spotify instance in order to interact with it.\n *\n * @api private\n */\n\nSpotify.prototype._parse = function (parser, data) {\n  var obj = parser.parse(data);\n  tag(this, obj);\n  return obj;\n};\n\n/**\n * XXX: move to `util`?\n * Attaches the `_spotify` property to each \"object\" in the passed in `obj`.\n *\n * @api private\n */\n\nfunction tag(spotify, obj){\n  if (obj === null || 'object' != typeof obj) return;\n  Object.keys(obj).forEach(function(key){\n    var val = obj[key];\n    var type = typeof val;\n    if ('object' == type) {\n      if (Array.isArray(val)) {\n        val.forEach(function (v) {\n          tag(spotify, v);\n        });\n      } else {\n        tag(spotify, val);\n      }\n    }\n  });\n  Object.defineProperty(obj, '_spotify', {\n    value: spotify,\n    enumerable: false,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * XXX: move to `util`?\n * Returns `true` if `val` is present in the `array`. Returns `false` otherwise.\n *\n * @api private\n */\n\nfunction has (array, val) {\n  var rtn = false;\n  if (Array.isArray(array)) {\n    rtn = !!~array.indexOf(val);\n  }\n  return rtn;\n}\n","/home/travis/build/npmtest/node-npmtest-spotify-web/node_modules/spotify-web/lib/util.js":"\n/**\n * Module dependencies.\n */\n\nvar base62 = require('./base62');\n\n/**\n * Converts a GID Buffer to an ID hex string.\n * Based off of Spotify.Utils.str2hex(), modified to work with Buffers.\n */\n\nexports.gid2id = function (gid) {\n  for (var b = '', c = 0, a = gid.length; c < a; ++c) {\n    b += (gid[c] + 256).toString(16).slice(-2);\n  }\n  return b;\n};\n\n/**\n * ID -> URI\n */\n\nexports.id2uri = function (uriType, v) {\n  var id = base62.fromHex(v, 22);\n  return 'spotify:' + uriType + ':' + id;\n};\n\n/**\n * URI -> ID\n *\n * >>> SpotifyUtil.uri2id('spotify:track:6tdp8sdXrXlPV6AZZN2PE8')\n * 'd49fcea60d1f450691669b67af3bda24'\n * >>> SpotifyUtil.uri2id('spotify:user:tootallnate:playlist:0Lt5S4hGarhtZmtz7BNTeX')\n * '192803a20370c0995f271891a32da6a3'\n */\n\nexports.uri2id = function (uri) {\n  var parts = uri.split(':');\n  var s;\n  if (parts.length > 3 && 'playlist' == parts[3]) {\n    s = parts[4];\n  } else {\n    s = parts[2];\n  }\n  var v = base62.toHex(s);\n  return v;\n};\n\n/**\n * GID -> URI\n */\n\nexports.gid2uri = function (uriType, gid) {\n  var id = exports.gid2id(gid);\n  return exports.id2uri(uriType, id);\n};\n\n/**\n * Accepts a String URI, returns the \"type\" of URI.\n * i.e. one of \"local\", \"playlist\", \"track\", etc.\n */\n\nexports.uriType = function (uri) {\n  var parts = uri.split(':');\n  var len = parts.length;\n  if (len >= 3 && 'local' == parts[1]) {\n    return 'local';\n  } else if (len >= 5) {\n    return parts[3];\n  } else if (len >= 4 && 'starred' == parts[3]) {\n    return 'playlist';\n  } else if (len >= 3) {\n    return parts[1];\n  } else {\n    throw new Error('could not determine \"type\" for URI: ' + uri);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-spotify-web/node_modules/spotify-web/lib/base62.js":"\n/**\n * From Spotify Web client code.\n * See: https://gist.github.com/4463921#file-spotify-web-client-js-L3503-L3546\n */\n\nmodule.exports = function () {\n  function g(a, b, c) {\n    for (var d = [0], f = [1], g = 0; g < a.length; ++g) {\n      for (var k = d, p = f, q = a[g], s = c, t = 0, y = 0; y < p.length; ++y) t = ~~k[y] + p[y] * q + t, k[y] = t % s, t = ~~ (t / s);\n      for (; t;) t = ~~k[y] + t, k[y] = t % s, t = ~~ (t / s), ++y;\n      k = f;\n      p = b;\n      q = c;\n      for (s = y = 0; s < k.length; ++s) y = k[s] * p + y, k[s] = y % q, y = ~~ (y / q);\n      for (; y;) k.push(y % q), y = ~~ (y / q)\n    }\n    return d\n  }\n  function f(a, b) {\n    for (var c = 0, d = []; c < a.length; ++c) d.push(b[a[c]]);\n    return d.reverse()\n  }\n  function d(a, b) {\n    for (; a.length < b;) a.push(0);\n    return a\n  }\n  for (var b = {}, c = {}, a = 0; a < 62; ++a) c[\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\" [a]] = a;\n  for (a = 0; a < 16; ++a) b[\"0123456789abcdef\" [a]] = a;\n  for (a = 0; a < 16; ++a) b[\"0123456789ABCDEF\" [a]] = a;\n  return {\n    fromBytes: function (a, b) {\n                 var c = g(a.slice(0).reverse(), 256, 62);\n                 return f(d(c, b), \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\").join(\"\")\n               },\n      toBytes: function (a, b) {\n                 var l = g(f(a, c), 62, 256);\n                 return d(l, b).reverse()\n               },\n      toHex: function (a, b) {\n               var l = g(f(a, c), 62, 16);\n               return f(d(l, b), \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\").join(\"\")\n             },\n      fromHex: function (a, c) {\n                 var l = g(f(a, b), 16, 62);\n                 return f(d(l,\n                       c), \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\").join(\"\")\n               }\n  }\n}();\n","/home/travis/build/npmtest/node-npmtest-spotify-web/node_modules/spotify-web/lib/schemas.js":"\n/**\n * Module dependencies.\n */\n\nvar fs = require('fs');\nvar path = require('path');\nvar debug = require('debug')('spotify-web:schemas');\n\ntry {\n  var protobuf = require('protobuf');\n  var protobufjs = null;\n} catch(e) {\n  var protobuf = null;\n  var protobufjs = require('protobufjs');\n}\n\n/**\n * Protocol Buffer schemas.\n */\n\nvar library = (protobuf) ? 'protobuf' : 'protobufjs';\n\nvar protoPath = path.resolve(__dirname, '..', 'proto');\n\nvar packageMapping = {\n  bartender: 'bartender',\n  mercury: 'mercury',\n  metadata: 'metadata',\n  playlist4: \"playlist4changes,playlist4content,playlist4issues,playlist4meta,playlist4ops,playlist4service\".split(\",\"),\n  pubsub: 'pubsub',\n  toplist: 'toplist'\n};\nvar packageCache = module.exports = {};\n\nvar loadPackage = function(id) {\n  // Use cached packages\n  if (packageCache.hasOwnProperty(id)) {\n    debug('loadPackage(%j) [%s, cached]', id, library);\n    return packageCache[id];\n  } else {\n    debug('loadPackage(%j) [%s]', id, library);\n  }\n\n  // Load the mapping of packages to proto files\n  var mapping = packageMapping[id];\n  if (!mapping) {\n    debug('No mapping for %s, assuming single proto file', id)\n    mapping = id;\n  }\n  if (!Array.isArray(mapping)) mapping = [mapping];\n\n  if (protobuf) {\n    // Protobuf works with compiled .desc files rather than .proto files and doesn't support imports\n    // Therefore, we load in each schema into an array and check each of them when looking for a message object\n    packageCache[id]= mapping.map(function(schema) {\n      return new protobuf.Schema(fs.readFileSync(path.resolve(protoPath, schema + '.desc')));\n    });\n    return packageCache[id];\n  \n  } else { // protobufjs\n    // Generate a proto string with import statements\n    var proto = mapping.map(function(schema) {\n      return 'import \"' + schema + '.proto\";';\n    }).join('\\n');\n\n    // Load the generated import file, and return the built package\n    var builder = protobufjs.protoFromString(proto, new protobufjs.Builder(), {root: protoPath, file: id+'_generated_import.proto'});\n    packageCache[id] = builder.build(\"spotify.\" + id + \".proto\");\n    return packageCache[id];\n  }\n};\n\nvar loadMessage = module.exports.build = function(packageId, messageId) {\n  debug('loadMessage(%j, %j) [%s]', packageId, messageId, library);\n  \n  var packageObj = loadPackage(packageId);\n  var messageObj = null;\n  \n  if (protobuf) {\n    var identifier = \"spotify.\" + packageId + \".proto.\" + messageId;\n    \n    // Loop though each loaded schema looking for the message\n    for (var i = 0; i < packageObj.length; i++) {\n      messageObj = packageObj[i][identifier];\n      if (messageObj) break;\n    }\n\n  } else { // protobufjs\n    // Load the message directly\n    messageObj = packageObj[messageId];\n\n    // Add wrapper functions\n    messageObj.parse = function protobufjs_parse_wrapper() {\n      debug('protobufjs_parse_wrapper(%j)', arguments);\n\n      // Call the message object decode function with the arguments\n      var message = messageObj.decode.apply(null, arguments);\n      // Convert the object keys to camel case, ByteBuffers to Node Buffers and then return the parsed object\n      return convertByteBuffersToNodeBuffers(reCamelCase(message));\n    }\n    messageObj.serialize = function protobufjs_serialize_wrapper() {\n      debug('protobufjs_serialize_wrapper(%j)', arguments);\n\n      // Convert any camel cased properties in the arguments to underscored properties\n      Array.prototype.map.call(arguments, function (argument) {\n        return deCamelCase(argument);\n      });\n\n      // Call the message object constructor with the modified arguments\n      var message = Object.create(messageObj.prototype);\n      message = messageObj.apply(message, arguments) || message;\n\n      // Return the node Buffer object containing the serialised data\n      return message.encodeNB();\n    };\n  }\n\n  return messageObj;\n};\n\nvar deCamelCase = function(obj) {\n  if (obj === null || 'object' != typeof obj) return obj;\n  Object.keys(obj).forEach(function(old_key) {\n    var new_key = old_key.replace(/([A-Z])/g, function($1){return \"_\"+$1.toLowerCase();});\n    obj[new_key] = deCamelCase(obj[old_key]);\n    if (new_key != old_key) delete obj[old_key];\n  });\n  return obj;\n};\n\nvar reCamelCase = function(obj) {\n  if (obj === null || 'object' != typeof obj) return obj;\n  Object.keys(obj).forEach(function(old_key) {\n    var new_key = old_key.replace(/(\\_[a-z])/g, function($1){return $1.toUpperCase().replace('_','');});\n    obj[new_key] = reCamelCase(obj[old_key]);\n    if (new_key != old_key) delete obj[old_key];\n  });\n  return obj;\n};\n\nvar convertByteBuffersToNodeBuffers = function(obj) {\n  if (obj === null || 'object' != typeof obj) return obj;\n  Object.keys(obj).forEach(function(key) {\n    // attempt to detect a bytebuffer object\n    if (obj[key] && obj[key].hasOwnProperty('array') && obj[key].hasOwnProperty('view')) {\n      obj[key] = obj[key].toBuffer();\n    } else {\n      obj[key] = convertByteBuffersToNodeBuffers(obj[key]);\n    }\n  });\n  return obj;\n};\n","/home/travis/build/npmtest/node-npmtest-spotify-web/node_modules/spotify-web/lib/error.js":"\n/**\n * Module dependencies.\n */\n\nvar inherits = require('util').inherits;\n\n/**\n * Error \"domains\".\n */\n\nvar domains = {\n  11: 'AuthorizationError',\n  12: 'TrackError',\n  13: 'HermesError',\n  14: 'HermesServiceError'\n};\n\n/**\n * Error \"codes\".\n */\n\nvar codes = {\n  0: 'Account subscription status not Spotify Premium',\n  1: 'Failed to send to backend',\n  8: 'Rate limited',\n  408: 'Timeout',\n  429: 'Too many requests'\n};\n\n/**\n * Module exports.\n */\n\nmodule.exports = SpotifyError;\n\n/**\n * Spotify error class.\n *\n * Sample `err` objects:\n *\n *   [ 11, 1, 'Invalid user' ]\n *   [ 12, 8, '' ]\n *   [ 14, 408, '' ]\n *   [ 14, 429, '' ]\n */\n\nfunction SpotifyError (err) {\n  this.domain = err[0] || 0;\n  this.code = err[1] || 0;\n  this.description = err[2] || '';\n  this.data = err[3] || null;\n\n  // Error impl\n  this.name = domains[this.domain];\n  var msg = codes[this.code];\n  if (this.description) msg += ' (' + this.description + ')';\n  this.message = msg;\n  Error.captureStackTrace(this, SpotifyError);\n}\ninherits(SpotifyError, Error);\n","/home/travis/build/npmtest/node-npmtest-spotify-web/node_modules/spotify-web/lib/artist.js":"\n/**\n * Module dependencies.\n */\n\nvar util = require('./util');\nvar Artist = require('./schemas').build('metadata', 'Artist');\nvar debug = require('debug')('spotify-web:artist');\n\n/**\n * Module exports.\n */\n\nexports = module.exports = Artist;\n\n/**\n * Artist URI getter.\n */\n\nObject.defineProperty(Artist.prototype, 'uri', {\n  get: function () {\n    return util.gid2uri('artist', this.gid);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n/**\n * Loads all the metadata for this Artist instance. Useful for when you get an only\n * partially filled Artist instance from an Album instance for example.\n *\n * @param {Function} fn callback function\n * @api public\n */\n\nArtist.prototype.get =\nArtist.prototype.metadata = function (fn) {\n  if (this._loaded) {\n    // already been loaded...\n    debug('artist already loaded');\n    return process.nextTick(fn.bind(null, null, this));\n  }\n  var spotify = this._spotify;\n  var self = this;\n  spotify.get(this.uri, function (err, artist) {\n    if (err) return fn(err);\n    // extend this Artist instance with the new one's properties\n    Object.keys(artist).forEach(function (key) {\n      if (!self.hasOwnProperty(key)) {\n        self[key] = artist[key];\n      }\n    });\n    fn(null, self);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-spotify-web/node_modules/spotify-web/lib/album.js":"\n/**\n * Module dependencies.\n */\n\nvar util = require('./util');\nvar Album = require('./schemas').build('metadata', 'Album');\nvar debug = require('debug')('spotify-web:album');\n\n/**\n * Module exports.\n */\n\nexports = module.exports = Album;\n\n/**\n * Album URI getter.\n */\n\nObject.defineProperty(Album.prototype, 'uri', {\n  get: function () {\n    return util.gid2uri('album', this.gid);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n/**\n * Loads all the metadata for this Album instance. Useful for when you get an only\n * partially filled Album instance from an Album instance for example.\n *\n * @param {Function} fn callback function\n * @api public\n */\n\nAlbum.prototype.get =\nAlbum.prototype.metadata = function (fn) {\n  if (this._loaded) {\n    // already been loaded...\n    debug('album already loaded');\n    return process.nextTick(fn.bind(null, null, this));\n  }\n  var spotify = this._spotify;\n  var self = this;\n  spotify.get(this.uri, function (err, album) {\n    if (err) return fn(err);\n    // extend this Album instance with the new one's properties\n    Object.keys(album).forEach(function (key) {\n      if (!self.hasOwnProperty(key)) {\n        self[key] = album[key];\n      }\n    });\n    fn(null, self);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-spotify-web/node_modules/spotify-web/lib/track.js":"\n/**\n * Module dependencies.\n */\n\nvar util = require('./util');\nvar Track = require('./schemas').build('metadata','Track');\nvar PassThrough = require('stream').PassThrough;\nvar debug = require('debug')('spotify-web:track');\n\n// node v0.8.x compat\nif (!PassThrough) PassThrough = require('readable-stream/passthrough');\n\n/**\n * Module exports.\n */\n\nexports = module.exports = Track;\n\n/**\n * Track URI getter.\n */\n\nObject.defineProperty(Track.prototype, 'uri', {\n  get: function () {\n    return util.gid2uri('track', this.gid);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n/**\n * Track Preview URL getter\n */\nObject.defineProperty(Track.prototype, 'previewUrl', {\n  get: function () {\n    var previewUrlBase = 'http://d318706lgtcm8e.cloudfront.net/mp3-preview/'\n    return this.preview.length && (previewUrlBase + util.gid2id(this.preview[0].fileId));\n  },\n  enumerable: true,\n  configurable: true\n})\n\n/**\n * Loads all the metadata for this Track instance. Useful for when you get an only\n * partially filled Track instance from an Album instance for example.\n *\n * @param {Function} fn callback function\n * @api public\n */\n\nTrack.prototype.get =\nTrack.prototype.metadata = function (fn) {\n  if (this._loaded) {\n    // already been loaded...\n    debug('track already loaded');\n    return process.nextTick(fn.bind(null, null, this));\n  }\n  var spotify = this._spotify;\n  var self = this;\n  spotify.get(this.uri, function (err, track) {\n    if (err) return fn(err);\n    // extend this Track instance with the new one's properties\n    Object.keys(track).forEach(function (key) {\n      if (!self.hasOwnProperty(key)) {\n        self[key] = track[key];\n      }\n    });\n    fn(null, self);\n  });\n};\n\n/**\n * Begins playing this track, returns a Readable stream that outputs MP3 data.\n *\n * @api public\n */\n\nTrack.prototype.play = function () {\n  // TODO: add formatting options once we figure that out\n  var spotify = this._spotify;\n  var stream = new PassThrough();\n\n  // if a song was playing before this, the \"track_end\" command needs to be sent\n  var track = spotify.currentTrack;\n  if (track && track._playSession) {\n    spotify.sendTrackEnd(track._playSession.lid, track.uri, track.duration);\n    track._playSession = null;\n  }\n\n  // set this Track instance as the \"currentTrack\"\n  spotify.currentTrack = track = this;\n\n  // initiate a \"play session\" for this Track\n  spotify.trackUri(track, function (err, res) {\n    if (err) return stream.emit('error', err);\n    if (!res.uri) return stream.emit('error', new Error('response contained no \"uri\"'));\n    debug('GET %s', res.uri);\n    track._playSession = res;\n    var req = spotify.agent.get(res.uri)\n      .set({ 'User-Agent': spotify.userAgent })\n      .end()\n      .request();\n    req.on('response', response);\n  });\n\n  function response (res) {\n    debug('HTTP/%s %s', res.httpVersion, res.statusCode);\n    if (res.statusCode == 200) {\n      res.pipe(stream);\n    } else {\n      stream.emit('error', new Error('HTTP Status Code ' + res.statusCode));\n    }\n  }\n\n  // return stream immediately so it can be .pipe()'d\n  return stream;\n};\n\n/**\n * Begins playing a preview of the track, returns a Readable stream that outputs MP3 data.\n *\n * @api public\n */\n\nTrack.prototype.playPreview = function () {\n  var spotify = this._spotify;\n  var stream = new PassThrough();\n  var previewUrl = this.previewUrl;\n\n  if (!previewUrl) {\n    process.nextTick(function() {\n      stream.emit('error', new Error('Track does not have preview available'));\n    });\n    return stream;\n  }\n\n  debug('GET %s', previewUrl);\n  var req = spotify.agent.get(previewUrl)\n    .set({ 'User-Agent': spotify.userAgent })\n    .end()\n    .request();\n  req.on('response', response);\n\n  function response (res) {\n    debug('HTTP/%s %s', res.httpVersion, res.statusCode);\n    if (res.statusCode == 200) {\n      res.pipe(stream);\n    } else {\n      stream.emit('error', new Error('HTTP Status Code ' + res.statusCode));\n    }\n  }\n\n  // return stream immediately so it can be .pipe()'d\n  return stream;\n};\n","/home/travis/build/npmtest/node-npmtest-spotify-web/node_modules/spotify-web/lib/image.js":"\n/**\n * Module dependencies.\n */\n\nvar gid2id = require('./util').gid2id;\nvar Image = require('./schemas').build('metadata','Image');\n\n/**\n * Module exports.\n */\n\nexports = module.exports = Image;\n\n/**\n * Image HTTP link getter.\n */\n\nObject.defineProperty(Image.prototype, 'uri', {\n  get: function () {\n    var spotify = this._spotify;\n    var base = spotify.sourceUrls[this.size];\n    return base + gid2id(this.fileId);\n  },\n  enumerable: true,\n  configurable: true\n});\n","/home/travis/build/npmtest/node-npmtest-spotify-web/node_modules/spotify-web/lib/restriction.js":"\n/**\n * Module dependencies.\n */\n\nvar util = require('./util');\nvar Restriction = require('./schemas').build('metadata','Restriction');\n\n/**\n * Module exports.\n */\n\nexports = module.exports = Restriction;\n\n/**\n * Allowed countries 2-letter code Array getter.\n */\n\nObject.defineProperty(Restriction.prototype, 'allowed', {\n  get: function () {\n    if (!this.countriesAllowed) return [];\n    return this.countriesAllowed.match(/[A-Z]{2}/g);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n/**\n * Forbidden countries 2-letter code Array getter.\n */\n\nObject.defineProperty(Restriction.prototype, 'forbidden', {\n  get: function () {\n    if (!this.countriesForbidden) return [];\n    return this.countriesForbidden.match(/[A-Z]{2}/g);\n  },\n  enumerable: true,\n  configurable: true\n});\n"}